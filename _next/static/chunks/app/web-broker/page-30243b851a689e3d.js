(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[704],{65380:function(e,t,r){Promise.resolve().then(r.bind(r,27178))},27178:function(e,t,r){"use strict";r.r(t),r.d(t,{default:function(){return W}});var i=r(57437),o=r(2265);let n="web-broker-ports-ready",s="worker-initialize-connection",a="create-fallback-connection",l="request-fallback-connection",c=e=>`ack-${e}`,d=new Map([["debug",0],["info",1],["warn",2],["error",3],["none",4]]);class h{static setGlobalLogLevel(e){h.LOG_LEVEL=e??"error"}constructor(...e){this.scopes=e}log(e,...t){let r=d.get(e)??3;(d.get(h.LOG_LEVEL)??3)<=r&&console.log(`[${(new Date).toISOString()}]`,...this.scopes.map(e=>`[${e}]`),...t)}warn(...e){this.log("warn",...e)}error(...e){this.log("error",...e)}info(...e){this.log("info",...e)}debug(...e){this.log("debug",...e)}static getLogger(...e){return new h(...e)}getLogger(...e){return new h(...this.scopes,...e)}}h.LOG_LEVEL="error",h.getLogger("@openfin/core-web/client");let w=e=>window.top===e,p=(e,t)=>{try{return e.origin===t.origin}catch(e){return!1}},g="openfin/web-shared-worker";class u{static get lockApi(){return navigator.locks}constructor(e){this.name=e,this.releaseCallback=null,u.pending.add(this),this.lockAcquiredPromise=new Promise((e,t)=>{this.lockReleasedPromise=u.lockApi.request(this.name,()=>(u.pending.delete(this),e(),new Promise(e=>{u.held.add(this),this.releaseCallback=e}))).catch(e=>{throw t(e),e})})}async acquired(){await this.lockAcquiredPromise}async release(){if(!this.releaseCallback)throw Error(`Lock ${this.name} not acquired.`);this.releaseCallback(),this.releaseCallback=null,await this.lockReleasedPromise,u.held.delete(this)}async onReleased(e){if(!this.lockReleasedPromise)throw Error(`Lock ${this.name} not queued.`);return this.lockReleasedPromise.then(e)}autoRelease(){this.acquired().then(()=>this.release())}static async releaseAll(){let e=Promise.all([...this.pending].map(async e=>{await e.acquired(),await e.release()}));await Promise.all([...this.held].map(async e=>{await e.release()})),await e}}u.pending=new Set,u.held=new Set;class m{constructor(e=100,t=2){this.pingIntervalMs=e,this.allowedMissedPings=t,this.lockSelf=async e=>{let t=new u(`__OPENFIN__${e.uuid}_${e.name}`);return await t.acquired(),t}}async lockProxiedConnection(e,t){let r=0;t.addEventListener("message",e=>{"pong"===e.data.topic&&r--});let i=await this.lockSelf(e),o=setInterval(()=>{r>=this.allowedMissedPings?(i.release(),clearInterval(o)):(r++,t.postMessage({topic:"ping"}))},this.pingIntervalMs);t.start()}registerProxiedConnection(e){e.addEventListener("message",t=>{"ping"===t.data.topic&&e.postMessage({topic:"pong"})}),e.start()}}class f{constructor(e,t,r){this.workerUrl=e,this.iframeWindow=t,this.forceWorker=r,this.identityDisconnectionController=new m,this.isSharedWorkerSupported=()=>!this.forceWorker&&!!window.SharedWorker,this.state="ready",this.establishWorkerConnectionViaWindow=async(e,t)=>{if(p(this.iframeWindow,e)){let r=new MessageChannel,i=new MessageChannel;return this.identityDisconnectionController.registerProxiedConnection(i.port1),new Promise((o,n)=>{r.port1.addEventListener("message",e=>{e.data.topic===c(a)&&(e.data.success?o(r.port1):n(e.data.reason))}),r.port1.start(),e.postMessage({topic:l,payload:{identity:t}},location.origin,[r.port2,i.port2])})}throw Error("Could not connect via top level browsing context as its origin does not much the web interop broker.")},this.listenForNestedConnections=e=>{"top-window"===this.state&&p(this.iframeWindow,this.iframeWindow.parent)&&this.iframeWindow.parent.addEventListener("message",async t=>{let{data:r}=t;if(t.origin===location.origin&&r.topic===l){let[i,...o]=t.ports;if(o.length>0&&r.payload?.identity){let[e]=o;await this.identityDisconnectionController.lockProxiedConnection(r.payload.identity,e)}e.postMessage({topic:a},[i])}})},this.initialize=async e=>{if("ready"!==this.state)throw Error("Worker connection already initialized");return(e=>{let t=r=>!(!(e=>{try{return!e.origin}catch(e){return!0}})(r)&&r.origin===e.origin)||!w(r)&&t(r.parent);return!w(e)&&t(e.parent)})(this.iframeWindow)&&p(this.iframeWindow,this.iframeWindow.top)?this.state="partitioned-frame":w(this.iframeWindow.parent)?this.state="top-window":this.state="frame",this.connect(e)}}async connect(e){if("ready"===this.state)throw Error("Must call initialize before connect");switch(this.state){case"partitioned-frame":return this.establishWorkerConnectionViaWindow(this.iframeWindow.top,e);case"top-window":{let t;return t=this.isSharedWorkerSupported()?new SharedWorker(this.workerUrl,g).port:new Worker(this.workerUrl),await this.identityDisconnectionController.lockSelf(e),this.listenForNestedConnections(t),t}case"frame":{if(!this.isSharedWorkerSupported())try{return await this.establishWorkerConnectionViaWindow(this.iframeWindow.top,e)}catch(e){throw Error(`SharedWorker is not supported and an unexpected error occured when trying to connect via fallback mechanism: ${e.message}`,{cause:e})}await this.identityDisconnectionController.lockSelf(e);let{port:t}=new SharedWorker(this.workerUrl,g);return t}default:throw this.state,Error(`Invalid state: ${this.state}`)}}}let k=h.getLogger("@openfin/core-web/iframe-broker"),y=()=>{let e=((e,t)=>{let r=RegExp(`^${t}<(?<meta>.*)>$`).exec(e)?.groups?.meta;if(r)try{return JSON.parse(atob(r))}catch(e){throw Error(`Failed to decode JSON from ${r}.`)}})(window.name,"of-broker");if(!e)throw Error("Invalid or missing identity string in iframe context. Ensure that this iframe is being renderered via the @openfin/core-web library.");return e},b=async e=>{try{h.setGlobalLogLevel(e.logLevel??"error");let{sharedWorkerUrl:t}=e;await ("loading"===document.readyState?new Promise(e=>{let t=()=>{e(),window.removeEventListener("DOMContentLoaded",t)};window.addEventListener("DOMContentLoaded",t)}):Promise.resolve());let r=y(),i=new f(t,window,"same-site"!==e.experimental?.crossTab),o=await i.initialize(r);k.info(`Loading ${t} in ${i.state} mode...`),(await (async(e,t,r)=>{let i=new MessageChannel,o=new MessageChannel,a={topic:s,payload:{identity:r}};await new Promise((e,r)=>{t.addEventListener("message",t=>{t.data.topic===c(s)&&(t.data.success?e():r(Error(t.data.reason)))}),t.start?.(),t.postMessage(a,[o.port2])});let l={topic:c(n),success:!0,payload:{identity:r}};return e.postMessage(l,"*",[i.port2,o.port1]),i.port1})(window.parent,o,r)).start(),o.start?.(),k.debug(`Port transfer complete in ${i.state} mode. Connection established with identity ${JSON.stringify(r)}. SharedWorker support=${i.isSharedWorkerSupported()}`)}catch(t){let e=Error(`An unexpected error occured during initialization. ${t.message}`);(function(e){let t={topic:c(n),success:!1,reason:e?.reason??"Connection Rejected"};window.parent.postMessage(t,"*")})({reason:e.message}),console.error(e)}};function W(){return(0,o.useEffect)(()=>{b({sharedWorkerUrl:"http://localhost:3000/worker.js",logLevel:"debug"})},[]),(0,i.jsx)("div",{children:(0,i.jsx)("h1",{children:"Web Broker"})})}}},function(e){e.O(0,[971,117,744],function(){return e(e.s=65380)}),_N_E=e.O()}]);